[
  {
    "objectID": "posts/week7-post.html",
    "href": "posts/week7-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 7 Reflection\nAs we didn’t have a lecture for this week, I will just briefly expand on our project idea and some embedded system news. Here is our project statement: The goal of our project is to create an interactive 2D physics engine that simulates the motion of small (sand-like) particle represented by pixels in a Earth-like gravity environment. The system will use a 64x64 LED matrix screen to display the simulation and an accelerometer to detect the device orientation. The particle will behave as if in a box-like 2D world with boundaries and moving similar to sand falling under gravity. The user would interact by rotating around the boundaries of the led screen to visualize the dynamic change in particle motion. We will see how much it changes as time moves on. The Embedded World 2024 just happened this October in Austin. Here are some hot takes: A major theme of the conference is the integration of AI to enhance functionality, there are some cool demonstration like speech recognition and generating driver code. They also discuss software-centric development shifts more than hardware-base especially in areas of automative industry where OTA (over-the-air) updates became essential. Under the EU’s Cyber Resilience Act, cybersecurity became a key concern of the embedded conference. Thus it looks like Rust became a popular programming language in its property of improving security and system integrity as an alternative to C89 under the context of IoT product development. Also, Zephyr, an open source RTOS, also draws a lot interests."
  },
  {
    "objectID": "posts/tenth-post.html",
    "href": "posts/tenth-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 10 Reflection\nThis week we have the design review on our project. The biggest question in our project is how to distribute the physics engine calculation correctly between FPGA and MCU (which appears to be a common problems among other projects as well). On the google form feedback, most students suggested do the calculation on MCUs given the fact that the FPGA has to be the one driving the display. For sample testcases without the display, most suggested hardcode the acceleration data and test with a single particle first to see if that simple motion match with expectations. For collision detection, we could make a simple by letting the particles stick and fall down together. For more complicated collision, we could go back to physics 24 regarding the 2D collision theory where the balls are like point masses. mass 2 is initially at reast conserve momentum along the original direction of mass 1(the x-axis)/ \\[\nm_1v_1=m_1v_1'cos θ_1 + m_2v_2'cos θ_2\n\\] This kinetic equaion provided us the before and after velocity along with angles after the collisions for the two point masses of equal mass: \\[\n1/2mv_1^2=1/2mv_1'^2 + 1/2mv_2'^2 + mv_1'v_2'cos(θ_1−θ_2)\n\\]"
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 2 Reflection\nThis week we learned in course on how to use the FPGA documentation, specifically how to find information we’d like (e.g. operating conditions) maunally without control F. We also further practiced how to write basic testbench review. Something useful I learned is that you don’t necessarily need to write out all testvectors to use run a testbenches, rather we can just start with some simple inputs and observe the simulation running results on the wave windows. We also refresh on C programming like what does volatile (use latest value rather than cached) mean and how to dereference. We also touch upon some MCU related design architecture but I think I’m still a bit confuse over how memory map works?\nAn article I read this week relating to embedded system is called Bluetooth Can Now Measure Distance, With Hardware Support En Route. The concept of bluetooth channel sounding that enable accurate distance measurement relates to a method called round tip timing which is thhe time between transmit and receive. Viewing through the lens of what we learned in Synchronous Design, RTT involves very very small time values so that if we don’t have high enough clock speed, we might not have accurate distance management.Time of flight (TOF) is half of RTT but includes some delays in the reflection system."
  },
  {
    "objectID": "posts/fourth-post.html",
    "href": "posts/fourth-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 4 Reflection\nIn class this week, we learned about CMSIS and how to configure interrupts to respond to on-board peripherals like GPIO pins and timers. From the ARM website, CMSIS is “a vendor-independent hardware abstraction layer of microcontrollers that are besed on Arm Cortex Processors.” The ARM website contains a lot of relevatn documentations and traning courses on their relevant architeectures and protocols. Rather recently, Rasberry Pi SDK released a new CMSIS Device Family Pack support for their product so that you can use their boards seamlessly with all of the Arm’s CMSIS tools. Previsously on Rasberry Pi Pico SDK. they don’t have the standard CMSIS core headers and register definitions (they used their own m0plus.h instead). Here is a link to this news released: https://www.raspberrypi.com/news/new-rp2040-cmsis-pack/. For the project, I looked up some beginner project using STM32 like temperature control, smart furniture control, waveform display, Rubik’scube solver etc. I;m currently debating between choosing a existing project as base and making extension on that or try to be creative to generate a completely new project but with risk to never work at all. Maybe I will just first brainstorm and take indpiration from my interest to generate a abstract topic to focus on?"
  },
  {
    "objectID": "posts/fifth-post..html",
    "href": "posts/fifth-post..html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 5 Reflection\nThis week in class we learned iot and duplex commmunication so that we can later configure the SPI interface between our STM32 and the temperature sensor. We discuss asynchronous (USART) vs. synchronous (SPI) serial interface that sychronous communication shared a clock between device while asynchronous communication does not. Here in Lab6 we are going to use ESP8266 wifi module to connected to the MCU so that their data can be transmitted wirelessly over WiFi to a webserver hosted on the ESP8266. IoT sensors are commonly used for environmental monitor and smart furniture projects. We could focus our project on such to make like a wearable device that track health or complicated IoT system like edge computing where processing done on the device rather cloud, this reduces latency and this techniques is usually used in autonomous vehicles. We could also secure our USART communication by making encrypted USART communication and Transport Layer Security over HTTP to ensure the integrity of our data. I think some ESP module might support such protocols."
  },
  {
    "objectID": "posts/eighth-post.html",
    "href": "posts/eighth-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 8 Reflection\nThis week we learned about AES encryption on FPGA making it to be a hardware accelerator. I also learned about how to use logic analyzer along with decoder to debug the hardware which came in handy we first configure the SPI protocols to see whether it’s actually sending or receiving bits (similar to debugger on segger but more on hardware side). Because this week’s content is on AES, I’m a bit curious over security over embedded system. Embedded security contains a lot of areas like side channel attacks (SCA) on cyber-physical systems, RISC-V wifi access point, fault injection attacks using ChipWhisperer board (past embedded security challenges: https://www.csaw.io/esc). In lab 6 we worked on Internet of Things device so I looked at data exfiltration attacks against IoT device. In our lab, we didn’t care about public sharing the temperature data so there isn’t an explicit unauthorized data exfiltration as we didn’t even bother to setup any defend mechanisms. Besides adding a Wi-Fi access point or web server authentication for users to enter password, we could use AES to encypt the data transferred. In the lab 6 SPI module, we could modify the SPI module to route data through the AES core. For outgoing data, the SPI module should send plaintext to the AES core for encryption before transmission. For incoming data, the SPI module should route ciphertext to the AES core for decryption before processing."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we aims to implement an IoT temperature sensing system using an STM32 microcontroller. a DS1722 temperature sensor and an ESP8266 module acting as the web server interface. The internet-accessible device can also control an on PCB LED. The primary functionality includes measuring temperature data, setting the resolution of the measurements, and displaying the results on a simple website. We also start learning how to use logic analyzer in debugging the SPI link and UART link for communication protocol’s implementation.\n\n\n\nHere is the hardware setup, the ESP8266 module is directly install on the corresponding on-board connectors.  I used a mix of CMSIS libraries for hardware abstraction and wrote the SPI libraries for direct register-level control. The code structures is approached through a modular level as follow:\n\nSPI and USART communication protocols\nDS1722 sensor Interaction functions\nWeb server and request handling functions for the ESP8266 module.\n\nThe ESP8266 receives HTTP requests from client using the GET requests for different actions like turning on/off the LED and setting temperature chip to differenet resolution. Here is a picture of the webpage displaying temperature at differnet resolutions:   In the DS1722 modules, we send instructions to the chip through SPI and receive 16 bit raw temperature (2 bytes) of Most Significant Bit (MSB) and Least Significant Bit (LSB). To form reasonable temperature data, the hiByte is shifted left by 8 bits and combined with loByte using a bitwise OR operation. This forms a 16-bit signed integer where the upper 8 bits are the integer part and the lower 8 bits represent fractional values. To convert this fixed-point value into a floating-point temperature reading, we divide by 256 (2^8).\nIn the SPI module, the protocol is configured with flexible options for baud rate (br), clock polarity (cpol), and clock phase (cpha), allowing the user to match the settings required by different SP I peripherals but in the main function I refer to the DS1722 datasheet for the corresponding values. I have a SPICSHIGH and SPICSLOW function to digitally write the CS pins high, do the transaction and then low. I set up a 2-line SPI (full-duplex mode) with an 8-bit data size. In the SendReceives function, it waits for the transmit buffer to be empty before sending data (TXE flag) and waits for the receive buffer to be filled before reading data (RXNE flag) to ensures synchronized data exchange. A pointer to the SPI data register (SPI1-&gt;DR) is used with a volatile cast to ensure direct and immediate read/write without compiler optimizations that may introduce delays. To test my design, I put my fingers on the temperature chip and refresh webpages to see temperature rises to close body temperature and used a dustor to spray in order to test for negative temperature.\nFurther, I used a logic analyzer to test my SPI transaction is working as normal. The following is a while loop of reading temperature only to show that we are sending and receiving appropriate values.  And here is an zoomed out version of the SPI communication when I refresh webpages:  The first line is clk, second line is CS, third line is CIPO and fourth line is COPI.\n\n\n\nI spend 30 hours on this lab mainly to configure the SPI protocols correctly and also was frustrated on the wire break within the breadboard causing connection issues."
  },
  {
    "objectID": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we aims to implement an IoT temperature sensing system using an STM32 microcontroller. a DS1722 temperature sensor and an ESP8266 module acting as the web server interface. The internet-accessible device can also control an on PCB LED. The primary functionality includes measuring temperature data, setting the resolution of the measurements, and displaying the results on a simple website. We also start learning how to use logic analyzer in debugging the SPI link and UART link for communication protocol’s implementation.\n\n\n\nHere is the hardware setup, the ESP8266 module is directly install on the corresponding on-board connectors.  I used a mix of CMSIS libraries for hardware abstraction and wrote the SPI libraries for direct register-level control. The code structures is approached through a modular level as follow:\n\nSPI and USART communication protocols\nDS1722 sensor Interaction functions\nWeb server and request handling functions for the ESP8266 module.\n\nThe ESP8266 receives HTTP requests from client using the GET requests for different actions like turning on/off the LED and setting temperature chip to differenet resolution. Here is a picture of the webpage displaying temperature at differnet resolutions:   In the DS1722 modules, we send instructions to the chip through SPI and receive 16 bit raw temperature (2 bytes) of Most Significant Bit (MSB) and Least Significant Bit (LSB). To form reasonable temperature data, the hiByte is shifted left by 8 bits and combined with loByte using a bitwise OR operation. This forms a 16-bit signed integer where the upper 8 bits are the integer part and the lower 8 bits represent fractional values. To convert this fixed-point value into a floating-point temperature reading, we divide by 256 (2^8).\nIn the SPI module, the protocol is configured with flexible options for baud rate (br), clock polarity (cpol), and clock phase (cpha), allowing the user to match the settings required by different SP I peripherals but in the main function I refer to the DS1722 datasheet for the corresponding values. I have a SPICSHIGH and SPICSLOW function to digitally write the CS pins high, do the transaction and then low. I set up a 2-line SPI (full-duplex mode) with an 8-bit data size. In the SendReceives function, it waits for the transmit buffer to be empty before sending data (TXE flag) and waits for the receive buffer to be filled before reading data (RXNE flag) to ensures synchronized data exchange. A pointer to the SPI data register (SPI1-&gt;DR) is used with a volatile cast to ensure direct and immediate read/write without compiler optimizations that may introduce delays. To test my design, I put my fingers on the temperature chip and refresh webpages to see temperature rises to close body temperature and used a dustor to spray in order to test for negative temperature.\nFurther, I used a logic analyzer to test my SPI transaction is working as normal. The following is a while loop of reading temperature only to show that we are sending and receiving appropriate values.  And here is an zoomed out version of the SPI communication when I refresh webpages:  The first line is clk, second line is CS, third line is CIPO and fourth line is COPI.\n\n\n\nI spend 30 hours on this lab mainly to configure the SPI protocols correctly and also was frustrated on the wire break within the breadboard causing connection issues."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This lab we moving towards microcontroller STM32 and configure the C code to use an I/O pin of MCU to play music on a 8ohms speaker based on the frequency and duration of each notes in the script. The major requirement lies with utilizing the datasheet of STM32L42KCU to configure the TIMER in playing out correct notes.\n\n\n\nI used two timers which function is configured to show in the following diagram  TIM16 is used for sound genetaion with a prescaler of 199 and TIM1 used for delay timing with a prescaler of 7999.\n\n\nTime Configuration Parameters: System clock: 80MHz, sound timer prescaler:199, delay timer prescaler:7999 Frequency Calculation The base timer frequency after my prescaler is: \\[\nf_{base}=\\dfrac{80MHz}{(199+1)}=400kHz\n\\] For a 16-bit timer: our maximum Auto-Reload Register (ARR) value is 65535 and the minimum ARR value would be 1 for toggle operation but will add one to account for the timer increments from 0 to ARR. Here is the minimum frequency (16-bit): \\[\nf_{min}=\\dfrac{400kHz}{65536}=6.1Hz\n\\] Here is the maximum frequency (16-bit): \\[\nf_{max}=\\dfrac{400kHz}{2}=200kHz\n\\] Now for the duration calculation, here is my delay timer base frequency: \\[\nf_{delay}=\\dfrac{80MHz}{(7999+1)}=10kHz\n\\] Here is my minimum duration (one timer count): \\[\nt_{min}=\\dfrac{1}{10kHz}=0.1ms\n\\] Here is my maximum duration: \\[\nt_{max}=\\dfrac{65535}{10kHz}=6.5535s\n\\] Now we can check the accuracy of the actual frequency vs. desired frequency using the equation that: \\[\nARR = \\dfrac{80MHz}{(199+1)f_{desired}}\n\\] As it’s too much notes types to check, I used a matlab generated codes calculation to check for all frequency of pitch A2 to A5 and also delay of all possible note types being used in the music piece: \nHardware Here is my schematics for lab 4:  The 10K potentiometer is used to control the volumne of the speaker, with more resistance the lower the volums. The LM386 voice amplifier is used to provide a 50 gain.\n\n\n\n\n\n\n\n\nI spent around 20 hours on this mostly due to unfamiliarity of writing C code and reading the datahseet."
  },
  {
    "objectID": "labs/lab4/lab4.html#lab-4-digital-audio",
    "href": "labs/lab4/lab4.html#lab-4-digital-audio",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This lab we moving towards microcontroller STM32 and configure the C code to use an I/O pin of MCU to play music on a 8ohms speaker based on the frequency and duration of each notes in the script. The major requirement lies with utilizing the datasheet of STM32L42KCU to configure the TIMER in playing out correct notes.\n\n\n\nI used two timers which function is configured to show in the following diagram  TIM16 is used for sound genetaion with a prescaler of 199 and TIM1 used for delay timing with a prescaler of 7999.\n\n\nTime Configuration Parameters: System clock: 80MHz, sound timer prescaler:199, delay timer prescaler:7999 Frequency Calculation The base timer frequency after my prescaler is: \\[\nf_{base}=\\dfrac{80MHz}{(199+1)}=400kHz\n\\] For a 16-bit timer: our maximum Auto-Reload Register (ARR) value is 65535 and the minimum ARR value would be 1 for toggle operation but will add one to account for the timer increments from 0 to ARR. Here is the minimum frequency (16-bit): \\[\nf_{min}=\\dfrac{400kHz}{65536}=6.1Hz\n\\] Here is the maximum frequency (16-bit): \\[\nf_{max}=\\dfrac{400kHz}{2}=200kHz\n\\] Now for the duration calculation, here is my delay timer base frequency: \\[\nf_{delay}=\\dfrac{80MHz}{(7999+1)}=10kHz\n\\] Here is my minimum duration (one timer count): \\[\nt_{min}=\\dfrac{1}{10kHz}=0.1ms\n\\] Here is my maximum duration: \\[\nt_{max}=\\dfrac{65535}{10kHz}=6.5535s\n\\] Now we can check the accuracy of the actual frequency vs. desired frequency using the equation that: \\[\nARR = \\dfrac{80MHz}{(199+1)f_{desired}}\n\\] As it’s too much notes types to check, I used a matlab generated codes calculation to check for all frequency of pitch A2 to A5 and also delay of all possible note types being used in the music piece: \nHardware Here is my schematics for lab 4:  The 10K potentiometer is used to control the volumne of the speaker, with more resistance the lower the volums. The LM386 voice amplifier is used to provide a 50 gain.\n\n\n\n\n\n\n\n\nI spent around 20 hours on this mostly due to unfamiliarity of writing C code and reading the datahseet."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Lab 2 is a continuation based on Lab 1’s work on a seven-segment display but instead of using a single display, we are using a dual display. The challenge lies in still using the same amount of I/O pins so we have to implement a time-multiplexing scheme. Time-multiplexing is a useful computer technique for data transmission, resource allocation, and reducing bandwidth. We are also learning how to use the FPGA Lattice manual to find operating conditions that would assist us in circuit building. \n\n\n\nWiring According to the iCE40UP Data sheet on page 34, the maximum current that can be drawn from the I/O pins is 8mA and the voltage drop for the PNP transistor is 0.7V. Using Ohm’s Law V=IR without V input being 3.3V, we would need to use a resistor that at least has: (3.3V-0.7V)/0.008A = 325 ohms. The closest upper-bounded one would be the 330 ohms resistor. I chose a 1k resistor just to be safe. For the LEDs, the resistor needs to have: (3.3V-2V)/0.02A = 65 ohms (see Lab 1 for details) and the closest choice is the 68 ohms resistor. We choose to use 2N3906 PNP transistors to drive large enough currents toward the anode pins of the dual display with an emitter on 3.3Vcpp and collector to the anode and base to the GPIO pins.  Software When developing the SystemVerilog module for this lab, I thought of reusing the independent seven-segment display module from lab 1 that contains all the combinational case statements for each switch combination. I have a freq_switch that basically toggles at a certain frequency determined by the counter and is later used to determine the status of the anode that declares which digits are on or off (only one can be on at the time). The sum is gotten by just performing binary summation on the two inputs s1 and s2. I used a high-speed oscillator that has a 24MHz frequency and a 12 bits counter so that my resulting flickering frequency would be: 24*10^6 / (2^12) = 5859 Hz which is more than enough for human eyes not to catch any lagging. Here is my source code and simulation at github\n\n\n\nThe following is the final schematic of the circuit.  The following is the block diagram for the structures of FPGA modules.  \n\n\n\nI wrote a testbench that didn’t cover all the cases but covers possible types of cases and edge cases of two same inputs, two different inputs. The format of testvectors is:input1_input2_anode_seg_sum. \nAs shown by the testbenches and uploading design onto the board to physically test out all possible combinations, the project at least achieved the goal of this lab 2 to display two digits simultaneously.  \nHowever, the organization and naming of the program are rather messy and seem to contain many unused variables. Thee names of variables didn’t capture the essence of their function (i.e. reset is not reset and anode is just the object name which could be confusing to know it’s function in the future). I started to get accustomed to the modular design approach of FPGA but still need to force myself to practice more on it like separating MUX into its modules and only using clk at the top modular level. The test benches could also need some rework in adding more cases and testing the clock cycles with the change of anode control separately from the summation. \n\n\n\nThis marks the preliminary success of lab2, I spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Lab 2 is a continuation based on Lab 1’s work on a seven-segment display but instead of using a single display, we are using a dual display. The challenge lies in still using the same amount of I/O pins so we have to implement a time-multiplexing scheme. Time-multiplexing is a useful computer technique for data transmission, resource allocation, and reducing bandwidth. We are also learning how to use the FPGA Lattice manual to find operating conditions that would assist us in circuit building. \n\n\n\nWiring According to the iCE40UP Data sheet on page 34, the maximum current that can be drawn from the I/O pins is 8mA and the voltage drop for the PNP transistor is 0.7V. Using Ohm’s Law V=IR without V input being 3.3V, we would need to use a resistor that at least has: (3.3V-0.7V)/0.008A = 325 ohms. The closest upper-bounded one would be the 330 ohms resistor. I chose a 1k resistor just to be safe. For the LEDs, the resistor needs to have: (3.3V-2V)/0.02A = 65 ohms (see Lab 1 for details) and the closest choice is the 68 ohms resistor. We choose to use 2N3906 PNP transistors to drive large enough currents toward the anode pins of the dual display with an emitter on 3.3Vcpp and collector to the anode and base to the GPIO pins.  Software When developing the SystemVerilog module for this lab, I thought of reusing the independent seven-segment display module from lab 1 that contains all the combinational case statements for each switch combination. I have a freq_switch that basically toggles at a certain frequency determined by the counter and is later used to determine the status of the anode that declares which digits are on or off (only one can be on at the time). The sum is gotten by just performing binary summation on the two inputs s1 and s2. I used a high-speed oscillator that has a 24MHz frequency and a 12 bits counter so that my resulting flickering frequency would be: 24*10^6 / (2^12) = 5859 Hz which is more than enough for human eyes not to catch any lagging. Here is my source code and simulation at github\n\n\n\nThe following is the final schematic of the circuit.  The following is the block diagram for the structures of FPGA modules.  \n\n\n\nI wrote a testbench that didn’t cover all the cases but covers possible types of cases and edge cases of two same inputs, two different inputs. The format of testvectors is:input1_input2_anode_seg_sum. \nAs shown by the testbenches and uploading design onto the board to physically test out all possible combinations, the project at least achieved the goal of this lab 2 to display two digits simultaneously.  \nHowever, the organization and naming of the program are rather messy and seem to contain many unused variables. Thee names of variables didn’t capture the essence of their function (i.e. reset is not reset and anode is just the object name which could be confusing to know it’s function in the future). I started to get accustomed to the modular design approach of FPGA but still need to force myself to practice more on it like separating MUX into its modules and only using clk at the top modular level. The test benches could also need some rework in adding more cases and testing the clock cycles with the change of anode control separately from the summation. \n\n\n\nThis marks the preliminary success of lab2, I spent 20 hours on this lab."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Xiyuan Liu (Amy) is a Junior Undergraduate Student at Harvey Mudd College majoring in Engineering with the concentration on computer and electric engineering. Her career interests are in the field of embeded systems and automation. In her free time, she enjoys making digital arts and watching animes. If you have any questions or suggestion regarding contents of this site, feel free to contact me through this email: amyliu01@g.hmc.edu."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Posts Section\n\n\n\n\n\n\n\n\n\n\n\nNov 15, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nNov 7, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nNov 1, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nOct 24, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nOct 18, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nOct 11, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nOct 4, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nSep 26, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nSep 19, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nSep 13, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nSep 6, 2024\n\n\nAmy Liu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Introduction The main goal of this assignment is to learn SMD in board assembly and learn how to use Lattice Radiant to write basic combinational System Verilog codes. By the end of this week’s lab, I hope I can learn how to write Verilog code to test out the hardware on board, perform logic simulations in Radiant, and deepen my understanding of circuit debugging. We are going to use on-board led to test the FPGA and also construct a functional hexadecimal 7-segment display.\nDesign Approach In the case of testing the board, the lab manual suggested implementing a XOR and AND relationship for the ON/OFF status of two led while letting the third led shine at 2.4 Hz. I used low speed oscillators with 10k Hz and counter [11:0] so that 10k/2^12 = 2.44Hz. I also included a reset to make sure the simulation works correctly and we are not starting at a random value every time. When working with the seven segment display, it’s good to use combinational logic to make case statements for each combination of 4 binary switches. I draw out the diagram for a seven segment display and assign seg[0] to be the segment a, seg[1] to be segment b according to the ascending order and assign free pins under FPGA for later breadboard testing. Here is the block diagram of the top module:  In order to provide 5-20mA of currents towards the segment LED, I choose to use a resistor of 68 ohms so that using ohm’s law(V=iR): I = (Vcc-Vf)/R = (3.3V-2.1V)/68 ohms =0.017A which is within the range of acceptable current. Here is the schematics for the circuit of 7 segment display: \nTesting Approach To make sure the design works as expected, I tested both through hardware breadboarding onto an actual 7 segment display led and also used QuestaSim inside Lattice Radiant. I ran through all possible combinations of 4 binary switches to ensure no edge cases are left.\nThis is picture for the output successful runthrough of testbenches: Seven-segment display \nXOR_AND \nConclusion The design meets all the requirements that we can alternate between 0-9 and A-F through controlling the four on-off switches. This is a picture of the board displaying on the letter F: \nNumber of hours spent: 18 hrs."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Introduction The main goal of this assignment is to learn SMD in board assembly and learn how to use Lattice Radiant to write basic combinational System Verilog codes. By the end of this week’s lab, I hope I can learn how to write Verilog code to test out the hardware on board, perform logic simulations in Radiant, and deepen my understanding of circuit debugging. We are going to use on-board led to test the FPGA and also construct a functional hexadecimal 7-segment display.\nDesign Approach In the case of testing the board, the lab manual suggested implementing a XOR and AND relationship for the ON/OFF status of two led while letting the third led shine at 2.4 Hz. I used low speed oscillators with 10k Hz and counter [11:0] so that 10k/2^12 = 2.44Hz. I also included a reset to make sure the simulation works correctly and we are not starting at a random value every time. When working with the seven segment display, it’s good to use combinational logic to make case statements for each combination of 4 binary switches. I draw out the diagram for a seven segment display and assign seg[0] to be the segment a, seg[1] to be segment b according to the ascending order and assign free pins under FPGA for later breadboard testing. Here is the block diagram of the top module:  In order to provide 5-20mA of currents towards the segment LED, I choose to use a resistor of 68 ohms so that using ohm’s law(V=iR): I = (Vcc-Vf)/R = (3.3V-2.1V)/68 ohms =0.017A which is within the range of acceptable current. Here is the schematics for the circuit of 7 segment display: \nTesting Approach To make sure the design works as expected, I tested both through hardware breadboarding onto an actual 7 segment display led and also used QuestaSim inside Lattice Radiant. I ran through all possible combinations of 4 binary switches to ensure no edge cases are left.\nThis is picture for the output successful runthrough of testbenches: Seven-segment display \nXOR_AND \nConclusion The design meets all the requirements that we can alternate between 0-9 and A-F through controlling the four on-off switches. This is a picture of the board displaying on the letter F: \nNumber of hours spent: 18 hrs."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This lab is an extension of previous labs using seven-segment display to show the reading of a matirx keypad. We would still use the time-multiplexing techniques in lab2 in addition to learn how to use FPGA to scan inputs from a keypad. We want to make sure no accidental short presses are recorded and display the two hexadecimal digits on the dual seven-segment display. Here is my github for this lab.\n\n\n\nHardware The circuit design is mostly similar to that of lab2 except for the new interface of a 4x4 matrix keypad connecting to the reading and scanning pins. I used pull-up resistor that all columns are HIGH at the beginning. In the logic for scanning the keypad (always_comb block), the rows are driven with one low bit and the rest high (4’b0111, 4’b1011, etc.). This is a common practice when scanning a keypad using a pull-up resistor configuration. Here is my schematics: \nModule Relationships The key modules I implemented are: The scanner_FSM that scan the incoming column signal and determine whether the pressed occured and then output signals to the row pins of the keypad along with decoder to record the active_row of the pressed key. The decoder translates the hexadecimal number based on the rows and columns and sent to the storage_ctrl module which would manage the most recent and second most recent value pressed. At the end, the display module would display the two digits given by the storage_ctrl module. Here is my block diagram: \nDebounce The debounce strategy I choose to implement is based upon a counter (debounce_counter) and limitation time (DEBOUNCE_TIME) in order to make sure the noise from the hardware are not registered to results in incorrect display. The debounce_counter would basically increments 1 every clock cycle until reaching the desired clock cycles to transition to the PRESS states, else we would stay at the debounce state or if key is released, we transfer back to the SCAN states. The advantage of this mehod is it’s accuracy in filtering out nose from the mechanical keys and gives flexibility by changing the DEBOUNCE_TIME to reflect for other kinds of switches or noise that may require fast or slower debounce time. However, the tradeoffs is there is a little delay in the display of digits as we need to have the debounce_counter to reach the DEBOUNCE TIME. Other possible methods could be implementing debounce on the hardware directly using a RC filter to only allow certain signals to pass through. This methods is quicker in response and also doesn’t take up any digital resources for making the debounce, the tradeoff would be we can’t adjust the filter as easy as the DEBOUNCE_TIME so we need to recalculate for the resistors and capcitors values each time for change in debounce requirements.  \nDigit Storage My storage_ctrl module used a simple two-register buffer (dig0，dig1) to control the storage of the last two recent presses on the keypad to be displayed where the most recent dig0 is on the right and the second most recent dig1 is on the left. This design is simple to implement and as it’s a separate module from the scanner module fsm, the modularization makes debugging process easier and has a less complicated (less states at least) fsm. This module can also later be used for other design purpose if needed.  \nScanning and Detecting I detect te rising edge of the key_pressed sgnal using the last_key meaning the digits would showup on the 7-segment display whenever the press happens. This helps me to achieve the goal of only register press once and during hold down, not register other presses nor repeating the register of the same digit being held down on the keypad. Another design choice is let the system respond to the key_pressed signals so that the display shows up upon the release of keys. The tradeoffs there however is higher response time of the display and doesn’t make intuitive to normal typing behaviors of people. For scanning, I choose to scan rows. Scanning columns would work basically the same. I could attempt parallel scanning but that’s over complicated for the purpose of the lab.  \n\n\n\nI used ModelSim on Radiant to simulate the possible scenarios of user pressing and check if the output meets expectation. The following is my testbench results for the top module and all modules without synchronizer. We can see that if the consecutive different presses occurred together within a short time period, the detected digits remains to tbe the first digit pressed and if the press last too short before released, key_pressed is not activated.  This is modules without synchronizer, it have similar behavior and did debouncing correctly only that it’s adjusted for a two-clock cycle delay for the asynchronous output. \n\n\n\nI spent around 41 hours on this lab to get a working scanner meeting all expectations. Most of the time are spent are the integration of debounce state and investigating clock used by different modules. If I were to do this lab again, I would use oscilloscope at early stage to see wether each state are triggered at the right time and condition rather than relying on the correctness of testbenches."
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This lab is an extension of previous labs using seven-segment display to show the reading of a matirx keypad. We would still use the time-multiplexing techniques in lab2 in addition to learn how to use FPGA to scan inputs from a keypad. We want to make sure no accidental short presses are recorded and display the two hexadecimal digits on the dual seven-segment display. Here is my github for this lab.\n\n\n\nHardware The circuit design is mostly similar to that of lab2 except for the new interface of a 4x4 matrix keypad connecting to the reading and scanning pins. I used pull-up resistor that all columns are HIGH at the beginning. In the logic for scanning the keypad (always_comb block), the rows are driven with one low bit and the rest high (4’b0111, 4’b1011, etc.). This is a common practice when scanning a keypad using a pull-up resistor configuration. Here is my schematics: \nModule Relationships The key modules I implemented are: The scanner_FSM that scan the incoming column signal and determine whether the pressed occured and then output signals to the row pins of the keypad along with decoder to record the active_row of the pressed key. The decoder translates the hexadecimal number based on the rows and columns and sent to the storage_ctrl module which would manage the most recent and second most recent value pressed. At the end, the display module would display the two digits given by the storage_ctrl module. Here is my block diagram: \nDebounce The debounce strategy I choose to implement is based upon a counter (debounce_counter) and limitation time (DEBOUNCE_TIME) in order to make sure the noise from the hardware are not registered to results in incorrect display. The debounce_counter would basically increments 1 every clock cycle until reaching the desired clock cycles to transition to the PRESS states, else we would stay at the debounce state or if key is released, we transfer back to the SCAN states. The advantage of this mehod is it’s accuracy in filtering out nose from the mechanical keys and gives flexibility by changing the DEBOUNCE_TIME to reflect for other kinds of switches or noise that may require fast or slower debounce time. However, the tradeoffs is there is a little delay in the display of digits as we need to have the debounce_counter to reach the DEBOUNCE TIME. Other possible methods could be implementing debounce on the hardware directly using a RC filter to only allow certain signals to pass through. This methods is quicker in response and also doesn’t take up any digital resources for making the debounce, the tradeoff would be we can’t adjust the filter as easy as the DEBOUNCE_TIME so we need to recalculate for the resistors and capcitors values each time for change in debounce requirements.  \nDigit Storage My storage_ctrl module used a simple two-register buffer (dig0，dig1) to control the storage of the last two recent presses on the keypad to be displayed where the most recent dig0 is on the right and the second most recent dig1 is on the left. This design is simple to implement and as it’s a separate module from the scanner module fsm, the modularization makes debugging process easier and has a less complicated (less states at least) fsm. This module can also later be used for other design purpose if needed.  \nScanning and Detecting I detect te rising edge of the key_pressed sgnal using the last_key meaning the digits would showup on the 7-segment display whenever the press happens. This helps me to achieve the goal of only register press once and during hold down, not register other presses nor repeating the register of the same digit being held down on the keypad. Another design choice is let the system respond to the key_pressed signals so that the display shows up upon the release of keys. The tradeoffs there however is higher response time of the display and doesn’t make intuitive to normal typing behaviors of people. For scanning, I choose to scan rows. Scanning columns would work basically the same. I could attempt parallel scanning but that’s over complicated for the purpose of the lab.  \n\n\n\nI used ModelSim on Radiant to simulate the possible scenarios of user pressing and check if the output meets expectation. The following is my testbench results for the top module and all modules without synchronizer. We can see that if the consecutive different presses occurred together within a short time period, the detected digits remains to tbe the first digit pressed and if the press last too short before released, key_pressed is not activated.  This is modules without synchronizer, it have similar behavior and did debouncing correctly only that it’s adjusted for a two-clock cycle delay for the asynchronous output. \n\n\n\nI spent around 41 hours on this lab to get a working scanner meeting all expectations. Most of the time are spent are the integration of debounce state and investigating clock used by different modules. If I were to do this lab again, I would use oscilloscope at early stage to see wether each state are triggered at the right time and condition rather than relying on the correctness of testbenches."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "The main goal of this lab is to determine the speed of motors by reading from a quadrature encoder through interrupts. In the debug terminal of segger we would see the design measures and displays speed of motors in rev/s with update rate of at lease 1Hz. Here is a cool gif showing how it works from our course website! \n\n\n\nOn the motors we have quad encoder +5V vcc and encoder A and B for signal outputs. So I first choose 5V-tolerant pins for encoder inputs to handle 5V encoder signals to make sure the board is not broken due to drawing too much current. Here is the schematics of my hardware:   I configured both encoder channels (A and B) external interrupts and used the hardware timer TIM2 for precise timing measurements. I also set Interrupt priorities to ensure encoder readings take precedence over other system tasks. To ensure accurate speed measurement and direction detection (switching pos and neg terminal on motor), I have the system to handles two interrupts source for dual channel monitoring. Both Interrupts would triggers on both rising and falling edges, clears the interrupt flag and compares ENCODER A and B states:  Within the main loop, we would calculates motor speed based on pulse count:  \\[\nSpeed_{rev/s} = \\dfrac{(Pulses_{counted} ) Scalefactor}{(PPR)  Interval}\n\\] Each encoder channel generates 360 pulse/s so using both edges of both channels would quadrables our resolution: \\[\nPPR = 360 * 4 = 1440.\n\\] Where the time interval is measured in ms so we have to convert it into s by divison of 1000: \\[\nTime_{s}=\\dfrac{time_{diff}}{1000}\n\\] At the end, we have:  \\[\nSpeed_{rev/s} = \\dfrac{(Pulses_{counted} ) (4.5)(1000)Scale_factor}{(1440)(time_{diff})}\n\\] For direction, I have positive indicate clockwise rotation and negative values for counter-clockwise rotation. For testing, I let the motors plug to 12 V to run at known reference speed of around 10 rev/s and also switched to negative 12 V to see a speed of around -10 rev/s. Besides manually counting edges, I also used a RPM meter based on the sounds of motor to determine the frequency to be around 1 Hz. Interrupt vs Polling Analysis\n\n\n\n\n\n\n\n\nfor…\nInterrupt\nPolling\n\n\n\n\nMotor at 12V\n9.918 rev/s\n15.9 rev/s\n\n\nAccuracy\n+/- &lt;0.05%\n+/- 50.3%\n\n\nResponse time\n&lt;1 μs\n~1ms\n\n\nCPU\nless\nmuch more\n\n\ncons\nneeds careful desigm\nmiss some pulses at high speeds\n\n\n\n\n\n\nI spend aroun 15 hours on this lab mostly because I didn’t see the starter codes updated…"
  },
  {
    "objectID": "labs/lab5/lab5.html#lab-5-interrupts",
    "href": "labs/lab5/lab5.html#lab-5-interrupts",
    "title": "E155 Portfolio",
    "section": "",
    "text": "The main goal of this lab is to determine the speed of motors by reading from a quadrature encoder through interrupts. In the debug terminal of segger we would see the design measures and displays speed of motors in rev/s with update rate of at lease 1Hz. Here is a cool gif showing how it works from our course website! \n\n\n\nOn the motors we have quad encoder +5V vcc and encoder A and B for signal outputs. So I first choose 5V-tolerant pins for encoder inputs to handle 5V encoder signals to make sure the board is not broken due to drawing too much current. Here is the schematics of my hardware:   I configured both encoder channels (A and B) external interrupts and used the hardware timer TIM2 for precise timing measurements. I also set Interrupt priorities to ensure encoder readings take precedence over other system tasks. To ensure accurate speed measurement and direction detection (switching pos and neg terminal on motor), I have the system to handles two interrupts source for dual channel monitoring. Both Interrupts would triggers on both rising and falling edges, clears the interrupt flag and compares ENCODER A and B states:  Within the main loop, we would calculates motor speed based on pulse count:  \\[\nSpeed_{rev/s} = \\dfrac{(Pulses_{counted} ) Scalefactor}{(PPR)  Interval}\n\\] Each encoder channel generates 360 pulse/s so using both edges of both channels would quadrables our resolution: \\[\nPPR = 360 * 4 = 1440.\n\\] Where the time interval is measured in ms so we have to convert it into s by divison of 1000: \\[\nTime_{s}=\\dfrac{time_{diff}}{1000}\n\\] At the end, we have:  \\[\nSpeed_{rev/s} = \\dfrac{(Pulses_{counted} ) (4.5)(1000)Scale_factor}{(1440)(time_{diff})}\n\\] For direction, I have positive indicate clockwise rotation and negative values for counter-clockwise rotation. For testing, I let the motors plug to 12 V to run at known reference speed of around 10 rev/s and also switched to negative 12 V to see a speed of around -10 rev/s. Besides manually counting edges, I also used a RPM meter based on the sounds of motor to determine the frequency to be around 1 Hz. Interrupt vs Polling Analysis\n\n\n\n\n\n\n\n\nfor…\nInterrupt\nPolling\n\n\n\n\nMotor at 12V\n9.918 rev/s\n15.9 rev/s\n\n\nAccuracy\n+/- &lt;0.05%\n+/- 50.3%\n\n\nResponse time\n&lt;1 μs\n~1ms\n\n\nCPU\nless\nmuch more\n\n\ncons\nneeds careful desigm\nmiss some pulses at high speeds\n\n\n\n\n\n\nI spend aroun 15 hours on this lab mostly because I didn’t see the starter codes updated…"
  },
  {
    "objectID": "posts/eleventh-post.html",
    "href": "posts/eleventh-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 11 Reflection\nThis week in class we learned about Direct Memory Access and configured DMA on the MCU using the tutorial sample code. I looked more into different DMA bus access schemes used in modern systems: Burst DMA that can performs large data transfers in concentrated bursts and have high speed performace in the cost of notable CPU idle periods, Cycle-Stealing DMA that operates between CPU instructions but has slower performance and transparent DMA that excutes single operations with CPU yield verification and eliminates CPU throtting (mechanism that would slow down a processor to reduce energy use)[1]. Interestingly most modern DMS controllers (like the DARWIN ARM microcontrollers) incorporates hardware acceleration for AES encryption as security protocols.\n Fig 1. Architecture of bust DMA during operations [1]\nCurrently, health and wearable devices that handle large amounts of data throughput but needs to be working for long period of time (requires low power consumption) which makes analog device that has the burst DMA architectures on MCU ideal for such low power werable devices[1]. Reference: [1]B. Hurst, “How to Accelerate Peripheral Monitoring in Low Power Wearables with DMA,” Analog.com, 2022. https://www.analog.com/en/resources/analog-dialogue/articles/how-to-accelerate-peripheral-monitoring-in-low-power-wearables-with-dma.html (accessed Nov. 16, 2024). ‌"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 1 Reflection\nThis week in lab I had learned SystemVerilog programming on Lattice Radiant through basic case statements and also how to use QuestaSim and testbenches in debugging and verifying the codes give desired outcome (similar to C++’s test cases). In Lecture, I learned about what is propagation delay and contamination delay in flip-flop and also the setup time constrains and holdtime constraints. These are useful knowledge coming into digital design interview and working with synchronous clock system. In class, we also practiced in designing a finite state machine. Through the lab checkoff this week, I realized the harm of floating reset could cause whether the led works depends on luck. The course really trained me up in developing determination in achieveing all the lab’s goal.\nThe AI Prototype turns out to work better than I imagined. I put in some sample codes and the truth table of the XOR-AND into chat-GPT 4 free trial. It’s outputs did successfully synthesized on first try. instead of using the simple operators like ^ and & for XOR and AND relation, chat-GPT just write a combinational case statements for each line of the truth table. Moreover, it doesn’t realized using a low-speed oscillator can make a 2.4 Hz blinking. Instead it kept the HSOSC module from sample code and says for reset (if counter &gt;= 10000000 begin) slow_clk &lt;= ~slow_clk; I’m not entirely sure what it means by slow_clk as there is almost no useful comments on the Chat-GPT code. There is also no reset.\n‌"
  },
  {
    "objectID": "posts/nineth-post.html",
    "href": "posts/nineth-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 9 Reflection\nThe week’s lecture we discussed how to contol liquid crystal displays with digital device and how to implement basic operation of the video graphics array protocol. Besides using FPGA, Graphics Processing Units (GPUs) are specialized digital devices designed to render images etc. for display on monitors. GPU came with predefined pipelines specialized for rendering tasks in high speed with little latency. GPUs are what we normally used in daily applications like gaming and computing. GPU is consists of the core procussing unit to handles graphical computation, Video Memory (VRAM) to store frame buffers and textures and display output interfaces port like VGA, HDMI to connect with monitor. Good graphics card (like NVIDIA GeForce RTX 4080) is really expensive but doesn’t really take much impact on daily usage of computer unless you are a gamer…"
  },
  {
    "objectID": "posts/sixth-post.html",
    "href": "posts/sixth-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 6 Reflection\nThis week I mainly worked on the project proposal with my partner Stephen Xu. Our initial idea is to build an RFID emulator that can open harvey mudd’s swipe system as it reads our cards’ swipe access but realized the 13.5MHz used by the HID system is hard to achieve throught our oscialltor on FPGA. This make sense as the frequency is set to make sure the security is hard to hack. In the history of RFID, 125kHz was first used for smaller transponders than campnay commercialized and move up to higher frequency range of 13.5MHz; there are also Ultra-High frequency RFID but never get commercialized. Then we thought to emulate 125kHz RFID and buy our own cards and RFID writer/reader module however as we plan out the handshake process, we felt like everything can be done on MCU while FPGA don’t have the opportunity to shine. So we turned towards the idea of physics engine inspired by the game beaker, where the user can interact with screen to move the object inside the container around."
  },
  {
    "objectID": "posts/third-post.html",
    "href": "posts/third-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 3 Reflection\nMoving (temporarily) away from FPGA, we are learning about STM32, one of the most classic starter MCU and refreshing upon C language. I learned C++ in CS70 so was a little bit familiar syntax wise (and the pointer memory address issue…) and unfamiliar (no classes and objects?!) to C. On my clinic project, I was programming esp32 SoCs through ESP-IDF and arduino. I found esp32 is much harder to learn for beginner though arduino language that based on C++ is more familiar to me but ESP-IDF is so complicated. Though, due to the arduino open-source community, I got the esp32 to blink and setup a BLE server quickly while for stm32, it took me some time to understand the clock configuration in the blinking tutorial.  Going back to the character development, I felt I really need to improve upon resourcefulness and adventurous character. After weeks of rewriting and banging my head on the code, I got my lab3 keypad scanner to work at Saturday 5:32pm using oscilloscope to detect the transition of states. I’m just one line (transition out of a condition in DEBOUNCE back to SCAN) towards complete work from a uncompletely random response:/ I didn’t find a AI prototype for this week’s lab, so I let send my fsm to chatGPT and let it make a art piece out of it:  Original fsm  The Symphony of States"
  }
]