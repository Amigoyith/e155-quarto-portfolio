[
  {
    "objectID": "posts/third-post.html",
    "href": "posts/third-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 3 Reflection\nMoving (temporarily) away from FPGA, we are learning about STM32, one of the most classic starter MCU and refreshing upon C language. I learned C++ in CS70 so was a little bit familiar syntax wise (and the pointer memory address issue…) and unfamiliar (no classes and objects?!) to C. On my clinic project, I was programming esp32 SoCs through ESP-IDF and arduino. I found esp32 is much harder to learn for beginner though arduino language that based on C++ is more familiar to me but ESP-IDF is so complicated. Though, due to the arduino open-source community, I got the esp32 to blink and setup a BLE server quickly while for stm32, it took me some time to understand the clock configuration in the blinking tutorial.  Going back to the character development, I felt I really need to improve upon resourcefulness and adventurous character. After weeks of rewriting and banging my head on the code, I got my lab3 keypad scanner to work at Saturday 5:32pm using oscilloscope to detect the transition of states. I’m just one line (transition out of a condition in DEBOUNCE back to SCAN) towards complete work from a uncompletely random response:/ I didn’t find a AI prototype for this week’s lab, so I let send my fsm to chatGPT and let it make a art piece out of it:  Original fsm  The Symphony of States"
  },
  {
    "objectID": "posts/seventh-post.html",
    "href": "posts/seventh-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 7 Reflection\nAs we didn’t have a lecture for this week, I will just briefly expand on our project idea and some embedded system news. Here is our project statement: The goal of our project is to create an interactive 2D physics engine that simulates the motion of small (sand-like) particle represented by pixels in a Earth-like gravity environment. The system will use a 64x64 LED matrix screen to display the simulation and an accelerometer to detect the device orientation. The particle will behave as if in a box-like 2D world with boundaries and moving similar to sand falling under gravity. The user would interact by rotating around the boundaries of the led screen to visualize the dynamic change in particle motion. We will see how much it changes as time moves on. The Embedded World 2024 just happened this October in Austin. Here are some hot takes: A major theme of the conference is the integration of AI to enhance functionality, there are some cool demonstration like speech recognition and generating driver code. They also discuss software-centric development shifts more than hardware-base especially in areas of automative industry where OTA (over-the-air) updates became essential. Under the EU’s Cyber Resilience Act, cybersecurity became a key concern of the embedded conference. Thus it looks like Rust became a popular programming language in its property of improving security and system integrity as an alternative to C89 under the context of IoT product development. Also, Zephyr, an open source RTOS, also draws a lot interests."
  },
  {
    "objectID": "posts/fourth-post.html",
    "href": "posts/fourth-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 4 Reflection\nIn class this week, we learned about CMSIS and how to configure interrupts to respond to on-board peripherals like GPIO pins and timers. From the ARM website, CMSIS is “a vendor-independent hardware abstraction layer of microcontrollers that are besed on Arm Cortex Processors.” The ARM website contains a lot of relevatn documentations and traning courses on their relevant architeectures and protocols. Rather recently, Rasberry Pi SDK released a new CMSIS Device Family Pack support for their product so that you can use their boards seamlessly with all of the Arm’s CMSIS tools. Previsously on Rasberry Pi Pico SDK. they don’t have the standard CMSIS core headers and register definitions (they used their own m0plus.h instead). Here is a link to this news released: https://www.raspberrypi.com/news/new-rp2040-cmsis-pack/. For the project, I looked up some beginner project using STM32 like temperature control, smart furniture control, waveform display, Rubik’scube solver etc. I;m currently debating between choosing a existing project as base and making extension on that or try to be creative to generate a completely new project but with risk to never work at all. Maybe I will just first brainstorm and take indpiration from my interest to generate a abstract topic to focus on?"
  },
  {
    "objectID": "posts/fifth-post..html",
    "href": "posts/fifth-post..html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 5 Reflection\nThis week in class we learned iot and duplex commmunication so that we can later configure the SPI interface between our STM32 and the temperature sensor. We discuss asynchronous (USART) vs. synchronous (SPI) serial interface that sychronous communication shared a clock between device while asynchronous communication does not. Here in Lab6 we are going to use ESP8266 wifi module to connected to the MCU so that their data can be transmitted wirelessly over WiFi to a webserver hosted on the ESP8266. IoT sensors are commonly used for environmental monitor and smart furniture projects. We could focus our project on such to make like a wearable device that track health or complicated IoT system like edge computing where processing done on the device rather cloud, this reduces latency and this techniques is usually used in autonomous vehicles. We could also secure our USART communication by making encrypted USART communication and Transport Layer Security over HTTP to ensure the integrity of our data. I think some ESP module might support such protocols."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Introduction \nLab 2 is a continuation based on Lab 1’s work on a seven-segment display but instead of using a single display, we are using a dual display. The challenge lies in still using the same amount of I/O pins so we have to implement a time-multiplexing scheme. Time-multiplexing is a useful computer technique for data transmission, resource allocation, and reducing bandwidth. We are also learning how to use the FPGA Lattice manual to find operating conditions that would assist us in circuit building. \nDesign and Testing Methodology Wiring According to the iCE40UP Data sheet on page 34, the maximum current that can be drawn from the I/O pins is 8mA and the voltage drop for the PNP transistor is 0.7V. Using Ohm’s Law V=IR without V input being 3.3V, we would need to use a resistor that at least has: (3.3V-0.7V)/0.008A = 325 ohms. The closest upper-bounded one would be the 330 ohms resistor. I chose a 1k resistor just to be safe. For the LEDs, the resistor needs to have: (3.3V-2V)/0.02A = 65 ohms (see Lab 1 for details) and the closest choice is the 68 ohms resistor. We choose to use 2N3906 PNP transistors to drive large enough currents toward the anode pins of the dual display with an emitter on 3.3Vcpp and collector to the anode and base to the GPIO pins.  Software When developing the SystemVerilog module for this lab, I thought of reusing the independent seven-segment display module from lab 1 that contains all the combinational case statements for each switch combination. I have a freq_switch that basically toggles at a certain frequency determined by the counter and is later used to determine the status of the anode that declares which digits are on or off (only one can be on at the time). The sum is gotten by just performing binary summation on the two inputs s1 and s2. I used a high-speed oscillator that has a 24MHz frequency and a 12 bits counter so that my resulting flickering frequency would be: 24*10^6 / (2^12) = 5859 Hz which is more than enough for human eyes not to catch any lagging.\nTechnical Documentation The following is the final schematic of the circuit.  The following is the block diagram for the structures of FPGA modules.  \nResults and Discussion I wrote a testbench that didn’t cover all the cases but covers possible types of cases and edge cases of two same inputs, two different inputs. The format of testvectors is:input1_input2_anode_seg_sum. \nAs shown by the testbenches and uploading design onto the board to physically test out all possible combinations, the project at least achieved the goal of this lab 2 to display two digits simultaneously.  \nHowever, the organization and naming of the program is rather messy and seems to contain many unused variables and the names of variables didn’t capture the essence of it’s function (i.e. reset is actual not reset and anode is just the object name which could be confusing to know it’s funciton in the future). I started to get accustomed to the modular design appraoch of FPGA but still needs to force myself to practice more on it like separating MUX into it’s own module and only use clk in the top modular level. The testbenches could also needs some rework in adding more cases and test the clock cycles with the change of anode control separately from the summation. \nConclusion This marks the preliminary success of lab2, I spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Introduction \nLab 2 is a continuation based on Lab 1’s work on a seven-segment display but instead of using a single display, we are using a dual display. The challenge lies in still using the same amount of I/O pins so we have to implement a time-multiplexing scheme. Time-multiplexing is a useful computer technique for data transmission, resource allocation, and reducing bandwidth. We are also learning how to use the FPGA Lattice manual to find operating conditions that would assist us in circuit building. \nDesign and Testing Methodology Wiring According to the iCE40UP Data sheet on page 34, the maximum current that can be drawn from the I/O pins is 8mA and the voltage drop for the PNP transistor is 0.7V. Using Ohm’s Law V=IR without V input being 3.3V, we would need to use a resistor that at least has: (3.3V-0.7V)/0.008A = 325 ohms. The closest upper-bounded one would be the 330 ohms resistor. I chose a 1k resistor just to be safe. For the LEDs, the resistor needs to have: (3.3V-2V)/0.02A = 65 ohms (see Lab 1 for details) and the closest choice is the 68 ohms resistor. We choose to use 2N3906 PNP transistors to drive large enough currents toward the anode pins of the dual display with an emitter on 3.3Vcpp and collector to the anode and base to the GPIO pins.  Software When developing the SystemVerilog module for this lab, I thought of reusing the independent seven-segment display module from lab 1 that contains all the combinational case statements for each switch combination. I have a freq_switch that basically toggles at a certain frequency determined by the counter and is later used to determine the status of the anode that declares which digits are on or off (only one can be on at the time). The sum is gotten by just performing binary summation on the two inputs s1 and s2. I used a high-speed oscillator that has a 24MHz frequency and a 12 bits counter so that my resulting flickering frequency would be: 24*10^6 / (2^12) = 5859 Hz which is more than enough for human eyes not to catch any lagging.\nTechnical Documentation The following is the final schematic of the circuit.  The following is the block diagram for the structures of FPGA modules.  \nResults and Discussion I wrote a testbench that didn’t cover all the cases but covers possible types of cases and edge cases of two same inputs, two different inputs. The format of testvectors is:input1_input2_anode_seg_sum. \nAs shown by the testbenches and uploading design onto the board to physically test out all possible combinations, the project at least achieved the goal of this lab 2 to display two digits simultaneously.  \nHowever, the organization and naming of the program is rather messy and seems to contain many unused variables and the names of variables didn’t capture the essence of it’s function (i.e. reset is actual not reset and anode is just the object name which could be confusing to know it’s funciton in the future). I started to get accustomed to the modular design appraoch of FPGA but still needs to force myself to practice more on it like separating MUX into it’s own module and only use clk in the top modular level. The testbenches could also needs some rework in adding more cases and test the clock cycles with the change of anode control separately from the summation. \nConclusion This marks the preliminary success of lab2, I spent 20 hours on this lab."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Xiyuan Liu (Amy) is a Junior Undergraduate Student at Harvey Mudd College majoring in Engineering with the concentration on computer and electric engineering. Her career interests are in the field of embeded systems and automation. In her free time, she enjoys making digital arts and watching animes. If you have any questions or suggestion regarding contents of this site, feel free to contact me through this email: amyliu01@g.hmc.edu."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Posts Section\n\n\n\n\n\n\n\n\n\n\n\nOct 18, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nOct 11, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nOct 4, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nSep 26, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nSep 19, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nSep 13, 2024\n\n\nAmy Liu\n\n\n\n\n\n\n\n\n\n\n\n\nPosts Section\n\n\n\n\n\n\n\n\n\n\n\nSep 6, 2024\n\n\nAmy Liu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Introduction The main goal of this assignment is to learn SMD in board assembly and learn how to use Lattice Radiant to write basic combinational System Verilog codes. By the end of this week’s lab, I hope I can learn how to write Verilog code to test out the hardware on board, perform logic simulations in Radiant, and deepen my understanding of circuit debugging. We are going to use on-board led to test the FPGA and also construct a functional hexadecimal 7-segment display.\nDesign Approach In the case of testing the board, the lab manual suggested implementing a XOR and AND relationship for the ON/OFF status of two led while letting the third led shine at 2.4 Hz. I used low speed oscillators with 10k Hz and counter [11:0] so that 10k/2^12 = 2.44Hz. I also included a reset to make sure the simulation works correctly and we are not starting at a random value every time. When working with the seven segment display, it’s good to use combinational logic to make case statements for each combination of 4 binary switches. I draw out the diagram for a seven segment display and assign seg[0] to be the segment a, seg[1] to be segment b according to the ascending order and assign free pins under FPGA for later breadboard testing. Here is the block diagram of the top module:  In order to provide 5-20mA of currents towards the segment LED, I choose to use a resistor of 68 ohms so that using ohm’s law(V=iR): I = (Vcc-Vf)/R = (3.3V-2.1V)/68 ohms =0.017A which is within the range of acceptable current. Here is the schematics for the circuit of 7 segment display: \nTesting Approach To make sure the design works as expected, I tested both through hardware breadboarding onto an actual 7 segment display led and also used QuestaSim inside Lattice Radiant. I ran through all possible combinations of 4 binary switches to ensure no edge cases are left.\nThis is picture for the output successful runthrough of testbenches: Seven-segment display \nXOR_AND \nConclusion The design meets all the requirements that we can alternate between 0-9 and A-F through controlling the four on-off switches. This is a picture of the board displaying on the letter F: \nNumber of hours spent: 18 hrs."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Introduction The main goal of this assignment is to learn SMD in board assembly and learn how to use Lattice Radiant to write basic combinational System Verilog codes. By the end of this week’s lab, I hope I can learn how to write Verilog code to test out the hardware on board, perform logic simulations in Radiant, and deepen my understanding of circuit debugging. We are going to use on-board led to test the FPGA and also construct a functional hexadecimal 7-segment display.\nDesign Approach In the case of testing the board, the lab manual suggested implementing a XOR and AND relationship for the ON/OFF status of two led while letting the third led shine at 2.4 Hz. I used low speed oscillators with 10k Hz and counter [11:0] so that 10k/2^12 = 2.44Hz. I also included a reset to make sure the simulation works correctly and we are not starting at a random value every time. When working with the seven segment display, it’s good to use combinational logic to make case statements for each combination of 4 binary switches. I draw out the diagram for a seven segment display and assign seg[0] to be the segment a, seg[1] to be segment b according to the ascending order and assign free pins under FPGA for later breadboard testing. Here is the block diagram of the top module:  In order to provide 5-20mA of currents towards the segment LED, I choose to use a resistor of 68 ohms so that using ohm’s law(V=iR): I = (Vcc-Vf)/R = (3.3V-2.1V)/68 ohms =0.017A which is within the range of acceptable current. Here is the schematics for the circuit of 7 segment display: \nTesting Approach To make sure the design works as expected, I tested both through hardware breadboarding onto an actual 7 segment display led and also used QuestaSim inside Lattice Radiant. I ran through all possible combinations of 4 binary switches to ensure no edge cases are left.\nThis is picture for the output successful runthrough of testbenches: Seven-segment display \nXOR_AND \nConclusion The design meets all the requirements that we can alternate between 0-9 and A-F through controlling the four on-off switches. This is a picture of the board displaying on the letter F: \nNumber of hours spent: 18 hrs."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "DEBOUNCE The debounce strategy I choose to implement is based upon a counter (debounce_counter) and limitation time (DEBOUNCE_TIME) in order to make sure the noise from the hardware are not registered to results in incorrect display. The debounce_counter would basically increments 1 every clock cycle until reaching the desired clock cycles to transition to the PRESS states, else we would stay at the debounce state or if key is released, we transfer back to the SCAN states. The advantage of this mehod is it’s accuracy in filtering out nose from the mechanical keys and gives flexibility by changing the DEBOUNCE_TIME to reflect for other kinds of switches or noise that may require fast or slower debounce time. However, the tradeoffs is there is a little delay in the display of digits as we need to have the debounce_counter to reach the DEBOUNCE TIME. Other possible methods could be implementing debounce on the hardware directly using a RC filter to only allow certain signals to pass through. This methods is quicker in response and also doesn’t take up any digital resources for making the debounce, the tradeoff would be we can’t adjust the filter as easy as the DEBOUNCE_TIME so we need to recalculate for the resistors and capcitors values each time for change in debounce requirements.   Digit Storage My storage_ctrl module used a simple two-register buffer (dig0，dig1) to control the storage of the last two recent presses on the keypad to be displayed where the most recent dig0 is on the right and the second most recent dig1 is on the left. This design is simple to implement and as it’s a separate module from the scanner module fsm, the modularization makes debugging process easier and has a less complicated (less states at least) fsm. This module can also later be used for other design purpose if needed.   Scanning and Detecting I detect te rising edge of the key_pressed sgnal using the last_key meaning the digits would showup on the 7-segment display whenever the press happens. This helps me to achieve the goal of only register press once and during hold down, not register other presses nor repeating the register of the same digit being held down on the keypad. Another design choice is let the system respond to the key_pressed signals so that the display shows up upon the release of keys. The tradeoffs there however is higher response time of the display and doesn’t make intuitive to normal typing behaviors of people. For scanning, I choose to scan rows. Scanning columns would work basically the same. I could attempt parallel scanning but that’s over complicated for the purpose of the lab.   ##### Test Benches"
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "E155 Portfolio",
    "section": "",
    "text": "DEBOUNCE The debounce strategy I choose to implement is based upon a counter (debounce_counter) and limitation time (DEBOUNCE_TIME) in order to make sure the noise from the hardware are not registered to results in incorrect display. The debounce_counter would basically increments 1 every clock cycle until reaching the desired clock cycles to transition to the PRESS states, else we would stay at the debounce state or if key is released, we transfer back to the SCAN states. The advantage of this mehod is it’s accuracy in filtering out nose from the mechanical keys and gives flexibility by changing the DEBOUNCE_TIME to reflect for other kinds of switches or noise that may require fast or slower debounce time. However, the tradeoffs is there is a little delay in the display of digits as we need to have the debounce_counter to reach the DEBOUNCE TIME. Other possible methods could be implementing debounce on the hardware directly using a RC filter to only allow certain signals to pass through. This methods is quicker in response and also doesn’t take up any digital resources for making the debounce, the tradeoff would be we can’t adjust the filter as easy as the DEBOUNCE_TIME so we need to recalculate for the resistors and capcitors values each time for change in debounce requirements.   Digit Storage My storage_ctrl module used a simple two-register buffer (dig0，dig1) to control the storage of the last two recent presses on the keypad to be displayed where the most recent dig0 is on the right and the second most recent dig1 is on the left. This design is simple to implement and as it’s a separate module from the scanner module fsm, the modularization makes debugging process easier and has a less complicated (less states at least) fsm. This module can also later be used for other design purpose if needed.   Scanning and Detecting I detect te rising edge of the key_pressed sgnal using the last_key meaning the digits would showup on the 7-segment display whenever the press happens. This helps me to achieve the goal of only register press once and during hold down, not register other presses nor repeating the register of the same digit being held down on the keypad. Another design choice is let the system respond to the key_pressed signals so that the display shows up upon the release of keys. The tradeoffs there however is higher response time of the display and doesn’t make intuitive to normal typing behaviors of people. For scanning, I choose to scan rows. Scanning columns would work basically the same. I could attempt parallel scanning but that’s over complicated for the purpose of the lab.   ##### Test Benches"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 1 Reflection\nThis week in lab I had learned SystemVerilog programming on Lattice Radiant through basic case statements and also how to use QuestaSim and testbenches in debugging and verifying the codes give desired outcome (similar to C++’s test cases). In Lecture, I learned about what is propagation delay and contamination delay in flip-flop and also the setup time constrains and holdtime constraints. These are useful knowledge coming into digital design interview and working with synchronous clock system. In class, we also practiced in designing a finite state machine. Through the lab checkoff this week, I realized the harm of floating reset could cause whether the led works depends on luck. The course really trained me up in developing determination in achieveing all the lab’s goal.\nThe AI Prototype turns out to work better than I imagined. I put in some sample codes and the truth table of the XOR-AND into chat-GPT 4 free trial. It’s outputs did successfully synthesized on first try. instead of using the simple operators like ^ and & for XOR and AND relation, chat-GPT just write a combinational case statements for each line of the truth table. Moreover, it doesn’t realized using a low-speed oscillator can make a 2.4 Hz blinking. Instead it kept the HSOSC module from sample code and says for reset (if counter &gt;= 10000000 begin) slow_clk &lt;= ~slow_clk; I’m not entirely sure what it means by slow_clk as there is almost no useful comments on the Chat-GPT code. There is also no reset.\n‌"
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 2 Reflection\nThis week we learned in course on how to use the FPGA documentation, specifically how to find information we’d like (e.g. operating conditions) maunally without control F. We also further practiced how to write basic testbench review. Something useful I learned is that you don’t necessarily need to write out all testvectors to use run a testbenches, rather we can just start with some simple inputs and observe the simulation running results on the wave windows. We also refresh on C programming like what does volatile (use latest value rather than cached) mean and how to dereference. We also touch upon some MCU related design architecture but I think I’m still a bit confuse over how memory map works?\nAn article I read this week relating to embedded system is called Bluetooth Can Now Measure Distance, With Hardware Support En Route. The concept of bluetooth channel sounding that enable accurate distance measurement relates to a method called round tip timing which is thhe time between transmit and receive. Viewing through the lens of what we learned in Synchronous Design, RTT involves very very small time values so that if we don’t have high enough clock speed, we might not have accurate distance management.Time of flight (TOF) is half of RTT but includes some delays in the reflection system."
  },
  {
    "objectID": "posts/sixth-post.html",
    "href": "posts/sixth-post.html",
    "title": "Posts Section",
    "section": "",
    "text": "Week 6 Reflection\nThis week I mainly worked on the project proposal with my partner Stephen Xu. Our initial idea is to build an RFID emulator that can open harvey mudd’s swipe system as it reads our cards’ swipe access but realized the 13.5MHz used by the HID system is hard to achieve throught our oscialltor on FPGA. This make sense as the frequency is set to make sure the security is hard to hack. In the history of RFID, 125kHz was first used for smaller transponders than campnay commercialized and move up to higher frequency range of 13.5MHz; there are also Ultra-High frequency RFID but never get commercialized. Then we thought to emulate 125kHz RFID and buy our own cards and RFID writer/reader module however as we plan out the handshake process, we felt like everything can be done on MCU while FPGA don’t have the opportunity to shine. So we turned towards the idea of physics engine inspired by the game beaker, where the user can interact with screen to move the object inside the container around."
  }
]